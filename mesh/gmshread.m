function msh = read_gmsh_mesh(filename)
% READ_GMSH_MESH  Read a Gmsh .msh mesh using meshio through Python.
%
% REQUIREMENTS:
%   pip install meshio
%   MATLAB must be configured to use a Python with meshio installed.
%
% OUTPUT struct fields:
%   msh.nodes           (N × 3)
%   msh.edges           (E × 2)
%   msh.triangles       (T × 3)     (if present)
%   msh.tets            (K × 4)     (if present)
%   msh.boundary_edges  (Eb × 2)
%   msh.boundary_nodes  (Nb × 1)

% -------------------------------------------------------------
% 1. Python helper (defined dynamically)
% -------------------------------------------------------------
pycode = [
"import meshio", newline, ...
"import numpy as np", newline, ...
"", newline, ...
"def loadmesh_m(filename):", newline, ...
"    m = meshio.read(filename)", newline, ...
"    out = {}", newline, ...
"", newline, ...
"    # Nodes -> list of lists", newline, ...
"    out['points'] = np.asarray(m.points).tolist()", newline, ...
"", newline, ...
"    # Default empty", newline, ...
"    out['tri'] = []", newline, ...
"    out['tet'] = []", newline, ...
"    out['edge'] = []", newline, ...
"    out['bnd_edge'] = []", newline, ...
"", newline, ...
"    # Cell blocks", newline, ...
"    for c in m.cells:", newline, ...
"        if c.type == 'triangle':", newline, ...
"            out['tri'] = np.asarray(c.data).tolist()", newline, ...
"        elif c.type == 'tetra':", newline, ...
"            out['tet'] = np.asarray(c.data).tolist()", newline, ...
"        elif c.type == 'line':", newline, ...
"            out['edge'] = np.asarray(c.data).tolist()", newline, ...
"", newline, ...
"    # Physical boundary line groups (2D or 3D boundary edges)", newline, ...
"    if hasattr(m, 'cell_sets'):", newline, ...
"        for name, grp in m.cell_sets.items():", newline, ...
"            if 'line' in grp:", newline, ...
"                for arr in grp['line']:", newline, ...
"                    out['bnd_edge'] += np.asarray(arr).tolist()", newline, ...
"", newline, ...
"    return out" ...
];

% Load helper into MATLAB’s Python engine
pyrun(pycode);


% -------------------------------------------------------------
% 2. Call Python loader
% -------------------------------------------------------------
data = pyrun("o = loadmesh_m(fname)", "o", fname=filename);



% -------------------------------------------------------------
% 3. Convert Python lists to MATLAB doubles
% -------------------------------------------------------------
%% --- Nodes ---
pts = data{'points'};        % py.list
pts_cell = cell(pts);        % MATLAB cell of py.list rows

% Convert each point r into a 1×2 double [x y]
pts_mat = cellfun(@(r) [ double(r{1}), double(r{2}) ], ...
                  pts_cell, 'UniformOutput', false);

% Now vertically stack
msh.nodes = vertcat(pts_mat{:});    % N×2

%% --- Triangles ---
tri_cell = cell(data{'tri'});
if isempty(tri_cell)
    msh.elements = [];
else
    tri_mat = cellfun(@(r) cellfun(@double, cell(r)), ...
                      tri_cell, 'UniformOutput', false);
    msh.elements = vertcat(tri_mat{:})+1;    % N×2
end


%% --- boundry Edges ---
edge_cell = cell(data{'edge'});
if isempty(edge_cell)
    msh.boundry_edges = [];
else
    edge_mat = cellfun(@(r) cellfun(@double, cell(r)), ...
                       edge_cell, 'UniformOutput', false);
    msh.boundary_edges = vertcat(edge_mat{:}) + 1;
end
msh.boundary_edges = sort(msh.boundary_edges,2);

tri = msh.elements;  % T×3

E = [
    tri(:, [1 2]);
    tri(:, [2 3]);
    tri(:, [3 1]);
];

% Sort endpoints so duplicates match
E = sort(E, 2);

% Remove duplicate interior edges
[E_unique, ~, ic] = unique(E, 'rows');

msh.edges = E_unique;

end
